#!/usr/bin/env node

const path = require('path')
const fs = require('fs')
const cli = require('cac')()
const esbuild = require('esbuild')
const crypto = require('crypto')

const loadStylePlugin = require('../lib/froxy/esbuild/plugins/load_style')
const envPlugin = require('../lib/froxy/esbuild/plugins/env')

const parsed = cli.parse()
const [absWorkingDir, entryPoint] = parsed.args
const entryPointKey = crypto.createHash('sha1').update(entryPoint).digest('base64')

const IMAGE_TYPES = /\.(png|gif|jpe?g|svg|ico|webp|avif)$/

const resolvePlugin = {
  name: 'froxy.resolver',
  setup(build) {
    const resolve = (b, p) => {
      return p.startsWith('/') ? path.resolve(absWorkingDir, p.slice(1)) : path.resolve(b, p)
    }

    build.onResolve({ filter: /\.css$/ }, args => {
      return {
        path: resolve(args.resolveDir, args.path),
        namespace: args.importer.endsWith('.js') ? 'cssFromJs' : 'file'
      }
    })

    // Mark as external if
    // build.onResolve({ filter: IMAGE_TYPES }, args => {
    //   console.log(args)
    //   return {
    //     path: resolve(args.resolveDir, args.path),
    //     namespace: 'image'
    //   }
    // })

    // Resolves paths starting with a `/` to the Rails root.
    //
    // Example:
    //  import '/my/lib.js' //-> import '{Rails.root}/my/lib.js'
    build.onResolve({ filter: /^\// }, args => {
      return {
        path: path.join(absWorkingDir, args.path)
      }
    })

    // Handles CSS imports from JS (eg `import from 'some.css'`) by simply marking it as external.
    // This then allows the browser to handle the import. However, browsers do not yet support
    // importing non-JS assets, and will not include the CSS. So the Froxy proxy will return the
    // imported CSS as a JS file that inserts the CSS directly into the DOM. This unfortunately may
    // result in a flash of unstyled content (FOUC).
    //
    // --- OR
    //
    // esbuild returns the content of both the JS and CSS. Then Froxy returns the JS as normal,
    // and additionally includes the CSS directly into the rendered HTML. This way, there will be no
    // FOUC. But this method is a little more complex, as Froxy will need to somehow pass the CSS
    // content to Rails for insertion into the rendered view.
    build.onLoad({ filter: /\.css$/, namespace: 'cssFromJs' }, args => ({
      contents: `
        import loadStyle from 'loadStyle'
        loadStyle("${args.path.slice(absWorkingDir.length)}")
      `,
      loader: 'js'
    }))

    // Handles images imported from JS or CSS.
    //
    // - Images imported from JS will return the URL of the image.
    // - Images imported from CSS will be marked as external, allowing the browser to handle it.
    build.onLoad({ filter: IMAGE_TYPES }, args => {
      return {
        contents: args.path.slice(absWorkingDir.length),
        loader: 'text'
      }
    })
  }
}

const buildOptions = {
  absWorkingDir,
  entryPoints: [entryPoint],
  bundle: true,
  format: 'esm',
  outdir: 'public/froxy/build',
  outbase: '.',
  define: {
    'process.env.NODE_ENV': `"${process.env.NODE_ENV || 'development'}"`,
    'process.env.RAILS_ENV': `"${process.env.RAILS_ENV || 'development'}"`
  },
  metafile: `public/froxy/meta/${entryPointKey}.json`,
  plugins: [envPlugin, loadStylePlugin, resolvePlugin]
}

esbuild
  .build(buildOptions)
  .catch(error => {
    console.error(error)
    process.exit(1)
  })
  .then(results => {
    console.log(results)
    // process.stdout.write(results.outputFiles[0].text)
    // process.stdout.write(fs.readFileSync(`${absWorkingDir}/${buildOptions.metafile}`, 'utf8'))
  })
